# Etcd 集群维护
[etcd 集群定期维护指南
](https://etcd.io/docs/v3.6/op-guide/maintenance/)

# 概述
etcd 集群需要`定期维护才能保持可靠性`。根据 etcd 应用程序的需求，此类维护通常可以`自动化执行`，且不会造成停机或显著的性能下降。


所有 etcd 维护工作都管理着 etcd 键空间所消耗的存储资源。如果无法充分控制key空间大小，则需要通过存储空间配额来保护；如果某个 etcd 成员的空间不足，配额将触发集群范围的警报，从而使系统进入受限操作维护模式。

为了`避免键空间写入空间不足`，必须压缩 etcd 键空间历史记录。存储空间本身可以通过对 etcd 成员进行`碎片整理来回收`。最后，定期对 etcd 成员状态进行快照备份，可以恢复任何因操作错误导致的意外逻辑数据丢失或损坏。


# Raft log retention(保持，保留)
etcd `--snapshot-count` 配置压缩前内存中保存的已应用的 Raft 条目数量。达到`--snapshot-count`数量时，服务器首先会将快照数据持久化到磁盘，然后截断旧条目。当速度较慢的Follower在压缩索引之前请求日志时，Leader会发送快照，强制Follower覆盖其状态。

`--snapshot-count`在快照前在内存中保存更多的Raft条目会导致更多的内存占用,从而导致内存占用率反复升高。


# 历史压缩:v3 API key-value database
由于 etcd 会保存其key空间的精确历史记录，因此应定期压缩此历史记录，以避免性能下降和最终的存储空间耗尽。压缩key空间历史记录会删除在给定key空间修订版本之前被取代的所有键的信息。这样，这些键占用的空间便可用于对键空间进行额外的写入。

etcd可以使用的时间窗口历史保留策略自动压缩键空间，也可以使用 手动压缩etcdctl。该etcdctl方法可以对压缩过程进行细粒度的控制，而自动压缩则适用于只需要一段时间内键历史记录的应用程序。

在 etcd 中，压缩（Compaction） 是一项至关重要的维护操作，它能够清理旧版本的键值数据，释放存储空间，还能提升读写性能。下面将深入剖析 etcd 压缩的原理、操作方法以及相关的注意事项。

## 一、压缩的基本原理

1.MVCC与版本存储

etcd 采用 MVCC（多版本并发控制）机制，每个键的每次修改都会生成一个新版本，这些版本会被永久保存，直到执行压缩操作。
- 全局修订号(Revision): 每次写操作都会生成一个唯一的全局递增的修订号。
- 历史版本: 同一个键的不同版本通过修订号进行区分。

2.为什么需要压缩
- 存储空间膨胀：若不进行压缩，旧版本数据会持续占用磁盘空间。
- 性能下降：过多的历史版本会增加快照和日志复制的负担。
- 内存占用增加: MVCC 索引会因为旧版本数据而变得臃肿。

3.压缩的本质
- 压缩操作会删除指定修订号之前的所有旧版本数据。
- 它是一种逻辑删除，物理空间的释放需要通过后续的碎片整理（Defragmentation）来完成。

## 二、手动压缩操作
1.查询当前修订号
```shell
# 获取当前修订号
./etcdctl --user root:root endpoint status -w json
```
```json
[
  {
    "Endpoint": "127.0.0.1:2379",
    "Status": {
      "header": {
        "cluster_id": 14841639068965178418,
        "member_id": 10276657743932975437,
        "revision": 9,    // 全局修订号
        "raft_term": 4
      },
      "version": "3.6.0",
      "dbSize": 98304,
      "leader": 10276657743932975437,
      "raftIndex": 86,
      "raftTerm": 4,
      "raftAppliedIndex": 86,
      "dbSizeInUse": 98304,
      "storageVersion": "3.6.0",
      "downgradeInfo": {}
    }
  }
]

```
2.执行压缩
```shell
# 压缩到修订号1000(删除所有<=1000 的旧版本)
etcdctl --user root:root compaction  <reversion>

# 强制压缩（忽略可能的并发冲突）
etcdctl --user root:root compaction  <reversion> --physical
```
3.碎片整理(释放物理空间)
```shell
 ./etcdctl --user root:root defrag
# Finished defragmenting etcd member[127.0.0.1:2379]. took 24.809ms
```

## 三、自动压缩配置
1.基于时间的自动压缩
```shell
# 每小时自动压缩一次
--auto-compaction-mod=periodic --auto-compaction-retention=1h

# 基于修订号的自动压缩
--auto-compaction-mod=revision --auto-compaction-retention=10000
```

## 四、压缩相关命令
```shell
# 查看压缩状态
etcdctl endpoint status -w json

# 查看历史版本
etcdctl get /key --rev=500
```

## 五、压缩的注意事项
1.与watch的关系
- 压缩会导致旧修订版本的 Watch 请求失败。
- 客户端应处理:`etcdserver: mvcc: required reversion has been compacted`错误。

2.性能影响
- 大规模压缩后可能会影响etcd的性能,建议低峰期进行。

3.物理空间释放
- 压缩后需要执行碎片整理才能真正的释放磁盘空间

4.安全线设置
- 避免压缩正在被客户端使用的 reversion
- 建议保留足够的历史版本(如24小时或100万修订号)

## 六、压缩策略建议
1.生产环境配置
```shell
# 保留48小时的历史版本
--auto-compaction-mode=periodic --auto-compaction-retention=48h

# 或者 保留100万的修订号
--auto-compaction-mode=reversion --auto-compaction-retention=1000000
```

2.监控指标
- 监控:`etcd_mvcc_db_total_size_in_bytes`和`etcd_mvcc_db_size_in_use_bytes`
- 设置告警阈值，例如超过80%时触发告警


# 碎片整理
对历史版本的key空间进行压缩后，etcd的数据库可能会出现内部碎片。任何内部碎片都是后端可以自由使用但仍然会消耗存储空间的空间。

etcd压缩旧修订版本会在后端数据库中留下空隙，从而产生内部碎片。碎片空间可以被后端使用，但etcd无法访问主机文件系统。换句话说`删除应用程序数据并不会回收磁盘空间`

碎片整理过程会将存储空间释放回文件系统。碎片整理是按照每个Member执行的。这样可避免集群范围内的延迟峰值。
```shell
# 对某个etcd Member 进行碎片整理
./etcdctl defrag
# Finished defragmenting etcd member[127.0.0.1:2379]
```

注意:对活动的Member进行碎片整理会在重建其状态时阻止系统的读写操作。
注意：`碎片整理不会在集群内复制`，一个碎片整理的请求只应用在当前Member。可以使用`--endpoints` 指定所有成员 或`--cluster`flag 自动查找集群所有Member。

```shell
# 对默认端点关联的集群进行碎片整理操作:
./etcdctl defrag --cluster
```
```shell
# 在 etcd 未运行时直接对 etcd 数据目录进行碎片整理
./etcdutl defrag --data-dir <path-to-etcd-data-dir>
```

# 空间配额
etcd空间配额确保集群以可靠的方式运行。如果没有空间配额，当etcd key空间增长过大时，可能会影响性能，或者耗尽存储空间时，从而导致集群不可预测的行为。

如果任何Member的 key 空间后端数据库超出空间配额，则会引起etcd集群范围的报警，使集群进入维护模式，仅接受key的读取和删除操作。只有在释放 key空间中的足够空间后才并对后端数据库进行碎片处理，并清除配额警报后，集群才能恢复正常运行。

默认情况下，etcd设置了适合大多数应用程序的保守空间配额，但可以在启动时候通过命令`flag`配置。以字节为单位。
```shell
./etcd --quota-backend-bytes=$((16 * 1024 * 1024))
```

# 快照备份
定期对etcd集群进行快照可以作为etcd key空间的持久备份。通过定期对etcd Member的后端数据库进行快照，可以将etcd集群恢复到已知良好的状态。
```shell
# 快照
etcdctl snapshot save backup.db

etcduti --write-out=table snapshot status backup.db
```